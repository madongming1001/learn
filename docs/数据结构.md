# Hashmap

## 插入路程图

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkdMVGljYUxZa3BiTldUZTBkVlRMRncxVEh1RWdFR2lhVkV3N0JoazBvVWRDVnNnN2dObG5yYUtuemljUEo2M3JiNDlvNFhRTTJWak5pY2ljdy8?x-oss-process=image/format,png)

## 扩容流程图

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkdMVGljYUxZa3BiTldUZTBkVlRMRncxb0Y0a0FsQU91c0s4SmlhS0Q3VVR5VzR2dE1CTWNCOTVZTXpKODZTdERaNDdkWmpsZXdiSVJFdy8?x-oss-process=image/format,png)

**而实际上 hash % length 等于 hash & ( length - 1) 的前提是 length 是 2 的 n 次幂**

**为什么是2的幂？**

**因为在插入元素时，元素定位的数组位置时把hashCode和容量进行按位与计算。** **使得2的次幂进行计算时可以减少碰撞的发生，并且让散列尽可能的均匀分布**

**resize方法**

（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12；

（2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方；

（3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍；

创建新数组

遍历数组，确定当前slot有值，先把当前就数组的这个slot位制空，

Case1:

如果不是链表的话**（e.next等于null）**直接赋值给新数组。

Case2:

如果是红黑树的话分割

Case3:

如果是链表创建两个链表一个是低位数组，一个是高位数组，如果原先值的高位&愿数组大小为0说明是新数组的原来数组位置，如果不为0说明是老数组位置+老数组容量，用了一个do
while循环不断的去添加两个地高数组。

# ConcurrentHashMap

**sizeCtl字段**

```java
// sizeCtl：默认为0，用来控制table的状态、以及初始化和扩容操作:
// sizeCtl < 0 表示table的状态:
//（1）=-1， 表示有其他线程正在进行初始化操作。（其他线程就不能再进行初始化，相当于一把锁）
//（2）= -(1 + nThreads)，表示有n个线程正在一起扩容。
// sizeCtl>=0表示table的初始化和扩容相关操作：
//（3）=0，默认值，后续在真正初始化table的时候使用，设置为默认容量DEFAULT_CAPACITY --> 16。
//（4）>0，将sizeCtl设置为table初始容量或扩容完成后的下一次扩容的门槛。
```

# 面试题

**为什么ConcurrentHashMap不允许插入null值？**

**ConcurrentHashMap的 key 和 value 不能为 null 主要是为了避免二义性。**null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，**那么你就无法区分这个键是否存在于 `ConcurrentHashMap` 中，还是根本没有这个键(containsKey)**。同样，如果你用 null 作为值，**那么你就无法区分这个值是否是真正存储在 `ConcurrentHashMap` 中的，还是因为找不到对应的键而返回的。(get)**

在单线程的hashmap可以通过hashMap.containsKey(key)判断是否存在此key，但是多线程并发的情况下判断不了concurrentHashMap.containsKey(key)，因为有可能在判断期间b线程调用了put(key,null)，这个时候返回的就不是预期的flase。get方法不知道是不存在该映射返回的null，还是映射的值本身是null

**ConcurrentHashMap 能保证复合操作的原子性吗？**

不能，但提供了相应的一些原子方法，putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge 比如比较实用的compute需求说有值加1没值就设置值。

**参考文章：**https://www.cnblogs.com/vipstone/p/15848849.html

**参考文章：**https://mp.weixin.qq.com/s/uvQsQ0ZbcBn05WShPBjU5Q

**tableSizeFor方法**

对任意十进制数转换为2的整数幂，结果是这个数本身的**最高有效位的前一位变成1，最高有效位以及其后的位都变为0，得到一个最接近length且大于length的2的n次幂数**。

核心思想是，先**将最高有效位以及其后的位都变为1**，最后再+1，就进位到前一位变成1，其后所有的满2变0。所以关键是**如何将最高有效位后面都变为1**。

**参考文章：**https://segmentfault.com/a/1190000039392972

**为什么 Map 桶中结点个数超过 8 才转为红黑树？**

TreeNodes(树) 占用空间是普通 Nodes(链表) 的两倍，所以只有当 bin(bucket 桶) 包含足够多的结点时才会转成 TreeNodes，而是否足够多就是由**TREEIFY_THRESH〇LD** 的值决定的。当 bin(bucket 桶) 中结点数变少时，又会转成普通的 bin(bucket 桶)。并且我们查看源码的时候发现，链表长度达到8 就转成红黑树，当长度降到 6 就转成普通 bin(bucket 桶)。

这样就解释了为什么不是一开始就将其转换为 TreeNodes，而是需要一定结点数之后才转为 TreeNodes，说白了就是权衡空间和时间。

这段内容还说到：当 hashCode 离散性很好的时候，树型 bin 用到的概率非常小，因为数据均匀分布在每个 bin 中，几乎不会有 bin中链表长度会达到阈值。但是在随机 hashCode 下，离散性可能会变差，然而 jdk 又不能阻止用户实现这种不好的 hash算法，因此就可能导致不均匀的数据分布。不理想情况下随机 hashCode 算法下所有 bin 中结点的分布频率会遵循泊松分布**（是一种统计与概率学里常见到的离散[概率分布]，泊松分布适合于描述单位时间内随机事件发生的次数。）**，我们可以看到，一个 bin
中链表长度达到 8 个元素的槪率为 0.00000006，几乎是不可能事件。所以，之所以选择 8，不是随便決定的，而是裉据概率统计决定的。甶此可见，发展将近30年的
Java 每一项改动和优化都是非常严谨和科学的。

# LongAdder

**参考文章：**https://blog.51cto.com/u_14518853/4893881

## 1、 设计思想上，LongAdder采用"分段"的方式降低CAS失败的频次

这里先简单的说下LongAdder的思路，后面还会详述LongAdder的原理。

我们知道，AtomicLong中有个内部变量value保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点数据，也就是N个线程竞争一个热点。

LongAdder的基本思路就是分散热点，将value值的新增操作分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个value值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。

LongAdder有一个全局变量volatile long base值，当并发不高的情况下都是通过CAS来直接操作base值，如果CAS失败，则针对LongAdder中的Cell[]数组中的Cell进行CAS操作，减少失败的概率。

例如当前类中base = 10，有三个线程进行CAS原子性的**+1操作**，线程一执行成功，此时base=11，线程二、线程三执行失败后开始针对于Cell[]数组中的Cell元素进行**+1操作**，同样也是CAS操作，此时数组index=1和index=2中Cell的value都被设置为了1.

## 2、使用Contended注解来消除伪共享

在 LongAdder 的父类 Striped64 中存在一个 volatile Cell[] cells; 数组，其长度是2 的幂次方，每个Cell都使用 @Contended注解进行修饰，而@Contended注解可以进行缓存行填充，从而解决伪共享问题。伪共享会导致缓存行失效，缓存一致性开销变大。

```java
@sun.misc.Contended 
static final class Cell {
}
```

伪共享指的是多个线程同时读写同一个缓存行的不同变量时导致的CPU缓存失效。尽管这些变量之间没有任何关系，但由于在主内存中邻近，存在于同一个缓存行之中，它们的相互覆盖会导致频繁的缓存未命中，引发性能下降。

## 3、惰性求值

LongAdder只有在使用longValue()获取当前累加值时才会真正的去结算计数的数据，longValue()方法底层就是调用sum()方法，对base和Cell数组的数据累加然后返回，做到数据写入和读取分离。而AtomicLong使用incrementAndGet()每次都会返回long类型的计数值，每次递增后还会伴随着数据返回，增加了额外的开销。

# 二叉树

## 二叉查找树

二叉树两种特殊形式，一个叫做满二叉树，另一个叫做完全二叉树。

**满二叉树**

一个二叉树的所有非叶子结点都存在左右孩子，并且所有叶子结点都在同一层上，那么这就树就是满二叉树。

**完全二叉树**

对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。

**搜索二叉树**

左侧节点都比右侧节点小，并且整个树没有重复节点

## 二叉树的递归套路

**对于递归遍历左树右树的时候是递归序列每个方法都会走进三次，先序、中序、后序都可以在递归序的基础上加工出来，第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序。**

1. 假设以x节点为头，假设可以向x左树和x右树要任何信息
2. 在上一步的假设下，讨论以x为头节点的树，得到答案的可能性（最重要）x有关 x无关
3. 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4. 把左树信息和右树信息求全集，就是任何一棵字数都需要返回的信息S
5. 递归函数都返回S，每一颗子树都这么要求
6. 写代码，在代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息

![image-20230913151510009](/Users/madongming/IdeaProjects/learn/docs/noteImg/image-20230913151510009.png)

## 二叉树的遍历

**从节点之间位置关系的角度来看，二叉树的遍历分为4种。**

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层序遍历

**从更宏观的角度来看，二叉树的遍历归结为两大类。**

1. **深度优先遍历**（前序遍历、中序遍历、后序遍历）
2. **广度优先遍历**（层序遍历）

**对于每个子树来说都是按照特定顺序输出，按照每个子树输出**

**前序遍历**

二叉树的前序遍历，输出顺序是**根结点、左子树、右子树**，先输出根节点，有左孩子就一直输出，知道没有，然后依次向上输出父节点的右孩子。

**中序遍历**

二叉树的中序遍历，输出顺序是**左子树、根节点、右子树，**先输出根节点的左孩子，如果这个左孩子还拥有左孩子，则继续深入访问下去，**一直找到不再有左孩子的节点，并输出该节点**，之后向上遍历并输出父节点及他的右孩子节点。

**后序遍历**

二叉树的后序遍历，输出顺序是**左子树、右子树、根节点**
，先访问左子树的叶子结点，从左开始往右依次输出，如果同级别没有了输出父节点的一样，完成左树的遍历，接着遍历右树的叶子节点也是从左往右，在往上寻找父节点。

二叉查找树平衡因子计算方式是 任意节点的左节点数量 - 右节点数量 = （-1、 0、 1）这三个值的时候，当所有节点的平衡因子都是
-1、0、1这三个值的时候，这棵二叉树才是一颗合格的AVL树。

## 树用数组存储的方式

使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组相应位置也空出来。

为什么这样设计呢？因为这样可以更方便地在数组中定位二叉树的孩子节点和父节点。

假设一个父节点的下标是parent，那么它的**左孩子节点下标就是2xparent+1**；**右孩子节点下标就是2xparent+2。**反过来，假设一个左孩子节点的下标是leftchild，那么他的**父节点下标就是(leftChild -1)/2**。

**如果父节点的位置为i，那么他的左孩子和右孩子的位置分别为2\*i+1和2\*i+2。**

**如果一个结点的位置为i,那么他的父节点的位置为（i-1）/2;**

**如果求父节点的父节点位置 直接父节点/2就可以得到**

假设节点4在数组中的下标为3，节点4时节点2的左孩子，节点2的下标可以直接通过计算得出。

**节点2的下标 = （3-1）/ 2 = 1**

1. 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
2. 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
3. 左、右子树也都是二叉查找树

**时间复杂度O（logn）**

# AVL树

平衡二叉树，是一种特殊的二叉查找树，也被称为AVL树。这个名字取自两位发明者G.M.Adelson-Velsky和E.M.Landis的姓氏首字符。这种数据结构之所以叫做平衡二叉树，就是因为它在每次插入、删除节点之后，可以进行"
自平衡"，也就是通过一系列调整重新达到平衡状态。

**平衡因子**：**对于AVL树的每一个节点，平衡因子是它的左子树高度和右子树高度的差值。**
只有当二叉树所有节点的平衡因子都是-1，0，1这三个值的时候，这颗二叉树才是一颗合格的AVL树。

**左旋**：以某个节点作为支点（旋转节点），其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右节点

**右旋**：以某个节点作为支点（旋转节点），其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左节点

![img](https://static001.geekbang.org/resource/image/0e/1e/0e37e597737012593a93105ebbf4591e.jpg)

**AVL树在什么情况下要进行左旋，什么情况下要进行右旋？AVL树的调整分为4种局面。**

1. **左左局面（LL）**

   祖父节点A有一个左孩子节点B，而节点B又有一个左孩子节点C。在这种局面下，我们以节点A为轴，进行**右旋操作**。

2. **右右局面（RR）**

   祖父节点A有一个右孩子节点B，而节点B又有一个右孩子节点C。在这种局面下，我们以节点A为轴，进行**左旋操作**。

3. **左右局面（LR）**

   祖父节点A有一个左孩子节点B，而节点B又有一个右孩子节点C。在这种局面下，我们先以节点B为轴，进行**左旋操作**
   。这样就转化成了左左局面。我们继续以节点A为轴，进行**右旋操作**。

4. **右左局面（RL）**

   祖父节点A有一个右孩子节点B，而节点B又有一个左孩子节点C。在这种局面下，我们先以节点B为轴，进行**右旋操作**
   。这样就转换成了右右局面。我们继续以节点A为轴，进行**左旋操作**。

# 红黑树

和AVL树类似，红黑树的存在目的也是为了维护二叉查找树的平衡。AVL树判断平衡的方式是通过平衡因子，二红黑树复杂一些，通过红色和黑色两种节点，以及若干规则来判断平衡。

**红黑树的规则如下**：

1. 根节点是黑色。
2. 节点是红色或黑色。
3. 每个叶子节点都是黑色的空节点（NIL节点）。
4. 每个红色节点的子节点都是黑色（既不存在两个连续的红色节点）。
5. 从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点。

# 拓扑排序

## AOV网（Activity On Vertex network）

用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，**弧表示活动之间的优先制约关系**，称这种有向图为*
*顶点表示活动的网**，简称AOV网。

AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，这是不允许的。

## AOE网（Activity On Edge）

用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以狐表示活动，**以顶点表示活动的开始或结束事件**，称这种有向图为**边表示活动的网**，简称AOV网。



# 队列

队列中的元素只能先入先出（FIFO），**队列的入口端叫做队尾，队列的出口端叫做队头。**