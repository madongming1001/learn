# Hashmap

## 插入路程图

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkdMVGljYUxZa3BiTldUZTBkVlRMRncxVEh1RWdFR2lhVkV3N0JoazBvVWRDVnNnN2dObG5yYUtuemljUEo2M3JiNDlvNFhRTTJWak5pY2ljdy8?x-oss-process=image/format,png)

## 扩容流程图

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkdMVGljYUxZa3BiTldUZTBkVlRMRncxb0Y0a0FsQU91c0s4SmlhS0Q3VVR5VzR2dE1CTWNCOTVZTXpKODZTdERaNDdkWmpsZXdiSVJFdy8?x-oss-process=image/format,png)

# ConcurrentHashMap

**sizeCtl字段**

```java
// sizeCtl：默认为0，用来控制table的状态、以及初始化和扩容操作:
// sizeCtl <0 表示table的状态:
//（1）=-1， 表示有其他线程正在进行初始化操作。（其他线程就不能再进行初始化，相当于一把锁）
//（2）= -(1 + nThreads)，表示有n个线程正在一起扩容。
// sizeCtl>=0表示table的初始化和扩容相关操作：
//（3）=0，默认值，后续在真正初始化table的时候使用，设置为默认容量DEFAULT_CAPACITY --> 16。
//（4）>0，将sizeCtl设置为table初始容量或扩容完成后的下一次扩容的门槛。
```
-----------------------------------
©著作权归作者所有：来自51CTO博客作者wx5d63d7686046d的原创作品，请联系作者获取转载授权，否则将追究法律责任
ConcurrentHashMap源码解析_03 put方法源码分析
https://blog.51cto.com/u_14518853/4893694



# 面试题

**为什么ConcurrentHashMap不允许插入null值？**

在单线程的hashmap可以通过hashMap.containsKey(key)判断是否存在此key，但是多线程并发的情况下判断不了concurrentHashMap.containsKey(key)，因为有可能在判断期间b线程调用了put(key,null)，这个时候返回的就不是预期的flase。

**参考文章：**https://www.cnblogs.com/vipstone/p/15848849.html

# tableSizeFor方法

对任意十进制数转换为2的整数幂，结果是这个数本身的**最高有效位的前一位变成1，最高有效位以及其后的位都变为0**。

核心思想是，先**将最高有效位以及其后的位都变为1**，最后再+1，就进位到前一位变成1，其后所有的满2变0。所以关键是**如何将最高有效位后面都变为1**。

**参考文章：**https://segmentfault.com/a/1190000039392972

# LongAdder

**参考文章：**https://blog.51cto.com/u_14518853/4893881

## 1、 设计思想上，LongAdder采用"分段"的方式降低CAS失败的频次

这里先简单的说下LongAdder的思路，后面还会详述LongAdder的原理。

我们知道，AtomicLong中有个内部变量value保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点数据，也就是N个线程竞争一个热点。

LongAdder的基本思路就是分散热点，将value值的新增操作分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个value值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。

LongAdder有一个全局变量volatile long base值，当并发不高的情况下都是通过CAS来直接操作base值，如果CAS失败，则针对LongAdder中的Cell[]数组中的Cell进行CAS操作，减少失败的概率。

例如当前类中base = 10，有三个线程进行CAS原子性的**+1操作**，线程一执行成功，此时base=11，线程二、线程三执行失败后开始针对于Cell[]数组中的Cell元素进行**+1操作**，同样也是CAS操作，此时数组index=1和index=2中Cell的value都被设置为了1.

## 2、使用Contended注解来消除伪共享

在 LongAdder 的父类 Striped64 中存在一个 volatile Cell[] cells; 数组，其长度是2 的幂次方，每个Cell都使用 @Contended 注解进行修饰，而@Contended注解可以进行缓存行填充，从而解决伪共享问题。伪共享会导致缓存行失效，缓存一致性开销变大。

```java
@sun.misc.Contended 
static final class Cell {
}
```

伪共享指的是多个线程同时读写同一个缓存行的不同变量时导致的 CPU缓存失效。尽管这些变量之间没有任何关系，但由于在主内存中邻近，存在于同一个缓存行之中，它们的相互覆盖会导致频繁的缓存未命中，引发性能下降。

## 3、惰性求值

LongAdder只有在使用longValue()获取当前累加值时才会真正的去结算计数的数据，longValue()方法底层就是调用sum()方法，对base和Cell数组的数据累加然后返回，做到数据写入和读取分离。

而AtomicLong使用incrementAndGet()每次都会返回long类型的计数值，每次递增后还会伴随着数据返回，增加了额外的开销。