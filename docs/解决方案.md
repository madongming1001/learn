# 用户权限设计

## 1.RBAC 权限模型概况

「用户-角色-权限」的权限逻辑就是目前行业内普遍使用的 RBAC （Role-Based Access Control：基于角色的权限控制）权限模型。其核心是引入角色的概念，用角色作为中间介质，使用户与权限配置更加灵活。

引入角色的好处是将抽象的权限具像化，我们仅需要思考每个角色应该赋予什么样的权限，再将对应的用户指向角色，即可完成账号授权。

# 过滤参数的几种方式

## 1、实现处理方法参数解析器接口

```java
//@Component
public class AuthParamResolver implements HandlerMethodArgumentResolver {
    @Override
    public boolean supportsParameter(MethodParameter methodParameter) {
        return methodParameter.getParameterType().equals(AuthParam.class);
    }

    @Override
    public Object resolveArgument(MethodParameter methodParameter, Message<?> message) throws Exception {
        Whitelist whitelist = methodParameter.getMethodAnnotation(Whitelist.class);
        // 通过 webRequest 和 whitelist 校验白名单
        return new AuthParam();
    }
}
```

## 2、注册FilterRegistrationBean、实现javax.servlet.Filter

```java
@Configuration
public class FilterConfiguration {
    @Bean
    public FilterRegistrationBean someFilterRegistration() {
        FilterRegistrationBean registration = new FilterRegistrationBean();
        registration.setFilter(new WhitelistFilter());
        registration.addUrlPatterns("/*");
        registration.setName("whitelistFilter");
        registration.setOrder(1); // 设置过滤器被调用的顺序
        return registration;
    }
}

public class WhitelistFilter implements javax.servlet.Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 初始化后被调用一次
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        // 判断是否需要拦截
        filterChain.doFilter(servletRequest, servletResponse); // 请求通过要显示调用
    }

    @Override
    public void destroy() {
        // 被销毁时调用一次

    }
}
```

## 3、通过AOP

```java
/**
 * @Author MaDongMing
 * @Date 2022/3/30 6:22 PM
 */
@Aspect
public class WhitelistAspect {
    @Before("whitelistPointCut() && @annotation(whitelist)")
    public void checkAppkeyWhitelist(JoinPoint joinPoint, Whitelist whitelist) {
//        checkWhitelist();
        // 可使用 joinPoint.getArgs() 获取Controller方法的参数
        // 可以使用 whitelist 变量获取注解参数
    }


    @Pointcut("@annotation(com.madm.learnroute.annotation.Whitelist)")
    public void whitelistPointCut() {
    }
}
```

## 4、通过实现WebMvcConfigurer注册，实现HandlerInterceptor

```java
public class AppkeyInterceptor implements HandlerInterceptor {

    private ApplicationContext applicationContext;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        applicationContext = SpringUtil.getApplicationContext();
        String applicationName = applicationContext.getApplicationName();
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        // 方法在Controller方法执行结束后执行
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 在view视图渲染完成后执行
    }
}
```

# 本地缓存

参考文章：缓存之王Caffeine Cache性能比Guava更强 

https://zhuanlan.zhihu.com/p/345175951

Caffeine 是基于 Google Guava Cache 设计经验改进的结果，相较于 Guava 在性能和命中率上更具有效率，你可以认为其是 Guava Plus。

## TinyLFU

TinyLFU 顾名思义，轻量级LFU，相比于 LFU 算法用更小的内存空间来记录访问频率。

TinyLFU 维护了近期访问记录的频率信息，不同于传统的 LFU 维护整个生命周期的访问记录，所以他可以很好地应对突发性的热点事件（超过一定时间，这些记录不再被维护）。这些访问记录会作为一个过滤器，当新加入的记录（New Item）访问频率高于将被淘汰的缓存记录（Cache Victim）时才会被替换。流程如下：



![img](https://pic3.zhimg.com/80/v2-79771c507d0c7b9e8f84c41489014742_720w.jpg)

tiny-lfu-arch

尽管维护的是近期的访问记录，但仍然是非常昂贵的，TinyLFU 通过 Count-Min Sketch 算法来记录频率信息，它占用空间小且误报率低，关于 Count-Min Sketch 算法可以参考论文：pproximating Data with the Count-Min Data Structure



# QPS和TPS

**QPS Queries Per Second 是每秒查询率：**是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，即每秒的响应请求数，也即是最大吞吐能力。软件的兼容性

**TPS Transactions Per Second 也就是事务数/秒：**一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束记时，以此来计算使用的时间和完成的事务个数。

## 如何评估系统或接口的QPS？

### nginx查询接口qps命令

```log
每分钟QPS
cat access.log | grep getCart | awk '{print $2}' | awk -F '-' '{print $1}' uniq -c
```

> AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。
>
> - -F fs or --field-separator fs
>   指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。

### 峰值时间计算法

首先评估业务的集中访问时间占比

> PV： page view，浏览量。 页面的浏览次数，衡量网站用户访问的网页数量，用户每打开/刷新一次页面就记录一次，多次打开会累计。

原理：每天80%的访问集中在一天的20%的时间里，这20%时间叫做峰值时间

公式：（总pv数 * 80%）/（每天秒数 * 20%） = 峰值时间每秒请求数（QPS）

机器：峰值时间每秒QPS/单台机器的QPS = 需要的机器

问：每天300w PV的单机机器上，这台机器有多少QPS？

答：（3000000 * 0.8）/（86400 * 0.2） = 139（QPS）

问：如果一台机器的QPS是58，需要几台机器来支持？

答：139 / 58 = 3



# 消息队列消息丢失和消息重复发送的处理策略

#### 基于 MQ 实现的分布式事务

**本地消息表-最终一致性** 

事务主动方 消息队列 事务被动方

1. 服务器处理消息需要是幂等的，消息的生产方和接收方都需要做到幂等性；
2. 发送放需要添加一个定时器来遍历重推未处理的消息，避免消息丢失，造成的事务执行断裂。

**MQ事务-最终一致性**

**RocketMQ事务**

RocketMQ 中的事务，它解决的问题是，确保执行本地事务和发消息这两个操作，要么都成功，要么都失败。并且，RocketMQ 增加了一个事务反查的机制，来尽量提高事务执行的成功率和数据一致性。

![图片](https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRzt6tcAxQb5bLxIzlkKd0bSW0yjfKoWaWTZUS6CbE8MYcuBJwjmIx1rOhoJ0avx3wZH4qR2ttDb9w/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)图片

主要是两个方面，正常的事务提交和事务消息补偿

正常的事务提交

1、发送消息（half消息），这个 half 消息和普通消息的区别，在事务提交 之前，对于消费者来说，这个消息是不可见的。

2、`MQ SERVER`写入信息，并且返回响应的结果；

3、根据`MQ SERVER`响应的结果，决定是否执行本地事务,如果`MQ SERVER`写入信息成功执行本地事务，否则不执行；

4、根据本地事务执行的状态，决定是否对事务进行 Commit 或者 Rollback。`MQ SERVER`收到 Commit，之后就会投递该消息到下游的订阅服务，下游的订阅服务就能进行数据同步，如果是 Rollback 则该消息就会被丢失；

如果`MQ SERVER`没有收到 Commit 或者 Rollback 的消息，这种情况就需要进行补偿流程了

补偿流程

1、`MQ SERVER`如果没有收到来自消息发送方的 Commit 或者 Rollback 消息，就会向消息发送端也就是我们的服务器发起一次查询，查询当前消息的状态；

2、消息发送方收到对应的查询请求，查询事务的状态，然后把状态重新推送给`MQ SERVER`，`MQ SERVER`就能之后后续的流程了。

相比于本地消息表来处理分布式事务，MQ 事务是把原本应该在本地消息表中处理的逻辑放到了 MQ 中来完成。

# System.currentTimeMillis有什么性能问题

随波逐流 人云亦云

参考文章：https://juejin.cn/post/6887743425437925383



# 方法命名建议

```text
注意：方法的名字指的是方法做了什么，而非怎么去做，最好是 **动词+名词** 格式

比如：Tom.扫地() √

 Tom.扫地With扫把() ×

 Tom.用扫把扫地() ×
```



# 代码单元

**代码单元**指一种转换格式（UTF）中最小的一个分隔，称为一个代码单元（Code Unit），因此，一种转换格式只会包含整数个单元，UTF-X 中的数字 X 就是各自代码单元的位数。UTF-16 的 16 指的就是最小为 16 位一个单元，也即两字节为一个单元，UTF-16 可以包含一个单元和两个单元，对应即是两个字节和四个字节。我们操作 UTF-16 时就是以它的一个单元为基本单位的。



## 查看一个字符串有几个字符

public class testStringLength {     public static void main(String [] args){         String B = "𝄞"; // 这个就是那个音符字符，只不过由于当前的网页没支持这种编码，所以没显示。         String C = "\uD834\uDD1E";// 这个就是音符字符的UTF-16编码         System.out.println(C);         System.out.println(B.length());         System.out.println(B.codePointCount(0,B.length()));         