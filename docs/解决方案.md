# 用户权限设计

## 1.RBAC 权限模型概况

「用户-角色-权限」的权限逻辑就是目前行业内普遍使用的 RBAC （Role-Based Access Control：基于角色的权限控制）权限模型。其核心是引入角色的概念，用角色作为中间介质，使用户与权限配置更加灵活。

引入角色的好处是将抽象的权限具像化，我们仅需要思考每个角色应该赋予什么样的权限，再将对应的用户指向角色，即可完成账号授权。

# 过滤参数的几种方式

## 1、实现处理方法参数解析器接口

```java
//@Component
public class AuthParamResolver implements HandlerMethodArgumentResolver {
    @Override
    public boolean supportsParameter(MethodParameter methodParameter) {
        return methodParameter.getParameterType().equals(AuthParam.class);
    }

    @Override
    public Object resolveArgument(MethodParameter methodParameter, Message<?> message) throws Exception {
        Whitelist whitelist = methodParameter.getMethodAnnotation(Whitelist.class);
        // 通过 webRequest 和 whitelist 校验白名单
        return new AuthParam();
    }
}
```

## 2、注册FilterRegistrationBean、实现javax.servlet.Filter

```java
@Configuration
public class FilterConfiguration {
    @Bean
    public FilterRegistrationBean someFilterRegistration() {
        FilterRegistrationBean registration = new FilterRegistrationBean();
        registration.setFilter(new WhitelistFilter());
        registration.addUrlPatterns("/*");
        registration.setName("whitelistFilter");
        registration.setOrder(1); // 设置过滤器被调用的顺序
        return registration;
    }
}

public class WhitelistFilter implements javax.servlet.Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 初始化后被调用一次
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        // 判断是否需要拦截
        filterChain.doFilter(servletRequest, servletResponse); // 请求通过要显示调用
    }

    @Override
    public void destroy() {
        // 被销毁时调用一次

    }
}
```

## 3、通过AOP

```java
/**
 * @Author MaDongMing
 * @Date 2022/3/30 6:22 PM
 */
@Aspect
public class WhitelistAspect {
    @Before("whitelistPointCut() && @annotation(whitelist)")
    public void checkAppkeyWhitelist(JoinPoint joinPoint, Whitelist whitelist) {
//        checkWhitelist();
        // 可使用 joinPoint.getArgs() 获取Controller方法的参数
        // 可以使用 whitelist 变量获取注解参数
    }


    @Pointcut("@annotation(com.madm.learnroute.annotation.Whitelist)")
    public void whitelistPointCut() {
    }
}
```

## 4、通过实现WebMvcConfigurer注册，实现HandlerInterceptor

```java
public class AppkeyInterceptor implements HandlerInterceptor {

    private ApplicationContext applicationContext;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        applicationContext = SpringUtil.getApplicationContext();
        String applicationName = applicationContext.getApplicationName();
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        // 方法在Controller方法执行结束后执行
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 在view视图渲染完成后执行
    }
}
```