# 用户权限设计

## 1.RBAC 权限模型概况

「用户-角色-权限」的权限逻辑就是目前行业内普遍使用的 RBAC （Role-Based Access Control：基于角色的权限控制）权限模型。其核心是引入角色的概念，用角色作为中间介质，使用户与权限配置更加灵活。

引入角色的好处是将抽象的权限具像化，我们仅需要思考每个角色应该赋予什么样的权限，再将对应的用户指向角色，即可完成账号授权。

# 过滤参数的几种方式

## 1、实现处理方法参数解析器接口

```java
//@Component
public class AuthParamResolver implements HandlerMethodArgumentResolver {
    @Override
    public boolean supportsParameter(MethodParameter methodParameter) {
        return methodParameter.getParameterType().equals(AuthParam.class);
    }

    @Override
    public Object resolveArgument(MethodParameter methodParameter, Message<?> message) throws Exception {
        Whitelist whitelist = methodParameter.getMethodAnnotation(Whitelist.class);
        // 通过 webRequest 和 whitelist 校验白名单
        return new AuthParam();
    }
}
```

## 2、注册FilterRegistrationBean、实现javax.servlet.Filter

```java
@Configuration
public class FilterConfiguration {
    @Bean
    public FilterRegistrationBean someFilterRegistration() {
        FilterRegistrationBean registration = new FilterRegistrationBean();
        registration.setFilter(new WhitelistFilter());
        registration.addUrlPatterns("/*");
        registration.setName("whitelistFilter");
        registration.setOrder(1); // 设置过滤器被调用的顺序
        return registration;
    }
}

public class WhitelistFilter implements javax.servlet.Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 初始化后被调用一次
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        // 判断是否需要拦截
        filterChain.doFilter(servletRequest, servletResponse); // 请求通过要显示调用
    }

    @Override
    public void destroy() {
        // 被销毁时调用一次

    }
}
```

## 3、通过AOP

```java
/**
 * @Author MaDongMing
 * @Date 2022/3/30 6:22 PM
 */
@Aspect
public class WhitelistAspect {
    @Before("whitelistPointCut() && @annotation(whitelist)")
    public void checkAppkeyWhitelist(JoinPoint joinPoint, Whitelist whitelist) {
//        checkWhitelist();
        // 可使用 joinPoint.getArgs() 获取Controller方法的参数
        // 可以使用 whitelist 变量获取注解参数
    }


    @Pointcut("@annotation(com.madm.learnroute.annotation.Whitelist)")
    public void whitelistPointCut() {
    }
}
```

## 4、通过实现WebMvcConfigurer注册，实现HandlerInterceptor

```java
public class AppkeyInterceptor implements HandlerInterceptor {

    private ApplicationContext applicationContext;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        applicationContext = SpringUtil.getApplicationContext();
        String applicationName = applicationContext.getApplicationName();
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        // 方法在Controller方法执行结束后执行
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 在view视图渲染完成后执行
    }
}
```

# 本地缓存

参考文章：缓存之王Caffeine Cache性能比Guava更强 

https://zhuanlan.zhihu.com/p/345175951

Caffeine 是基于 Google Guava Cache 设计经验改进的结果，相较于 Guava 在性能和命中率上更具有效率，你可以认为其是 Guava Plus。

## TinyLFU

TinyLFU 顾名思义，轻量级LFU，相比于 LFU 算法用更小的内存空间来记录访问频率。

TinyLFU 维护了近期访问记录的频率信息，不同于传统的 LFU 维护整个生命周期的访问记录，所以他可以很好地应对突发性的热点事件（超过一定时间，这些记录不再被维护）。这些访问记录会作为一个过滤器，当新加入的记录（New Item）访问频率高于将被淘汰的缓存记录（Cache Victim）时才会被替换。流程如下：



![img](https://pic3.zhimg.com/80/v2-79771c507d0c7b9e8f84c41489014742_720w.jpg)

tiny-lfu-arch

尽管维护的是近期的访问记录，但仍然是非常昂贵的，TinyLFU 通过 Count-Min Sketch 算法来记录频率信息，它占用空间小且误报率低，关于 Count-Min Sketch 算法可以参考论文：pproximating Data with the Count-Min Data Structure



# QPS和TPS

**QPS Queries Per Second 是每秒查询率：**是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，即每秒的响应请求数，也即是最大吞吐能力。软件的兼容性

**TPS Transactions Per Second 也就是事务数/秒：**一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束记时，以此来计算使用的时间和完成的事务个数。

## 如何评估系统或接口的QPS？

### nginx查询接口qps命令

```log
每分钟QPS
cat access.log | grep getCart | awk '{print $2}' | awk -F '-' '{print $1}' uniq -c
```

> AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。
>
> - -F fs or --field-separator fs
>   指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。

### 峰值时间计算法

首先评估业务的集中访问时间占比

> PV： page view，浏览量。 页面的浏览次数，衡量网站用户访问的网页数量，用户每打开/刷新一次页面就记录一次，多次打开会累计。

原理：每天80%的访问集中在一天的20%的时间里，这20%时间叫做峰值时间

公式：（总pv数 * 80%）/（每天秒数 * 20%） = 峰值时间每秒请求数（QPS）

机器：峰值时间每秒QPS/单台机器的QPS = 需要的机器

问：每天300w PV的单机机器上，这台机器有多少QPS？

答：（3000000 * 0.8）/（86400 * 0.2） = 139（QPS）

问：如果一台机器的QPS是58，需要几台机器来支持？

答：139 / 58 = 3



